<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Maze Captcha System</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #000000;
            color: #ffffff;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: #1a1a1a;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        h1 {
            color: #ffffff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .subtitle {
            color: #888888;
            font-size: 1.1rem;
            font-weight: 400;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-bottom: 60px;
        }
        
        .section {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 8px;
        }
        
        .section-title {
            font-size: 1.5rem;
            color: #ffffff;
            margin-bottom: 20px;
            border-bottom: 2px solid #333333;
            padding-bottom: 10px;
            font-weight: 600;
        }
        
        .captcha-container {
            text-align: center;
            margin: 20px 0;
        }
        
        #mazeCanvas {
            border: 2px solid #333333;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            background: #ffffff;
        }
        
        .verify-section {
            text-align: center;
            margin: 20px 0;
        }
        
        .controls {
            display: flex;
            gap: 18px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 12px 25px;
            border: 2px solid #333333;
            background: #2a2a2a;
            color: #ffffff;
            font-size: 16px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        button:hover {
            background: #0052cc;
            border-color: #0052cc;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: #2a2a2a;
            border: 1px solid #333333;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333333;
        }
        
        .status {
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
            border-radius: 8px;
        }
        
        .status.success {
            background: #1a3a1a;
            color: #4ade80;
            border: 2px solid #4ade80;
        }
        
        .status.error {
            background: #3a1a1a;
            color: #f87171;
            border: 2px solid #f87171;
        }
        
        .status.info {
            background: #1a2a3a;
            color: #60a5fa;
            border: 2px solid #60a5fa;
        }
        
        .hidden {
            display: none;
        }
        
        .recent-events {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .event-item {
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid;
            background: white;
        }
        
        .human-event {
            border-left-color: #4ade80;
        }
        
        .bot-event {
            border-left-color: #f87171;
        }
        
        .system-event {
            border-left-color: #666;
        }
        
        .event-time {
            font-size: 0.9em;
            color: #666;
            display: block;
            margin-bottom: 4px;
        }
        
        .event-type {
            font-weight: 600;
            color: #333;
            display: block;
            margin-bottom: 4px;
        }
        
        .event-confidence {
            font-size: 0.85em;
            color: #666;
            display: block;
        }
        
        .event-reasons {
            font-size: 0.8em;
            color: #666;
            margin-top: 4px;
        }
        
        .event-wall {
            font-size: 0.8em;
            color: #dc3545;
            margin-top: 4px;
        }
        
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: #2a2a2a;
            padding: 20px;
            text-align: center;
            border: 1px solid #333333;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #0066ff;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #888888;
            font-size: 0.9rem;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
            background: #2a2a2a;
            padding: 15px;
            border: 1px solid #333333;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Production Maze Captcha System</h1>
            <div class="subtitle">AI-Powered Bot Detection with Human Behavior Learning</div>
        </header>
        
        <div class="main-content">
            <section class="section">
                <h2 class="section-title">Captcha Challenge</h2>
                
                <div class="captcha-container">
                    <canvas id="mazeCanvas" width="400" height="400"></canvas>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff00;"></div>
                        <span>Start</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff0000;"></div>
                        <span>End</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #0066ff;"></div>
                        <span>Your Path</span>
                    </div>
                </div>
                
                <div class="controls">
                    <button onclick="loadNewCaptcha()">New Captcha</button>
                    <button onclick="clearPath()">Clear Path</button>
                    <button onclick="verifySolution()">Verify Solution</button>
                    <button onclick="simulateBot()">Simulate Bot</button>
                </div>
                
                <div class="verify-section">
                    <button onclick="verifySolution()" disabled>Verify Solution</button>
                </div>
                
                <div id="status" class="status hidden"></div>
            </section>
            
            <section class="section">
                <h2 class="section-title">Real-Time Analytics</h2>
                
                <div class="analytics-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalAttempts">0</div>
                        <div class="stat-label">Total Attempts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="successRate">0%</div>
                        <div class="stat-label">Success Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="botDetected">0</div>
                        <div class="stat-label">Bots Detected</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="patternsLearned">0</div>
                        <div class="stat-label">Patterns Learned</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgSolveTime">0s</div>
                        <div class="stat-label">Avg Solve Time</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="learnedPatterns">0</div>
                        <div class="stat-label">Learned Patterns</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="wallTouchTolerance">Max 3+1 per 10 steps</div>
                        <div class="stat-label">Wall Touch Tolerance</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="sessionCount">0</div>
                        <div class="stat-label">Active Sessions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgConfidence">0%</div>
                        <div class="stat-label">Avg Confidence</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="performanceChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Learning Progress</h3>
                    <canvas id="learningChart"></canvas>
                </div>
</section>

<section class="section">
    <h2 class="section-title">Advanced Analytics</h2>
    <div class="grid" style="grid-template-columns: 1fr 1fr;">
        <div class="chart-container">
            <h3>Path Length Distribution</h3>
            <canvas id="pathLengthHistogram"></canvas>
        </div>
        <div class="chart-container">
            <h3>Confidence Score Distribution</h3>
            <canvas id="confidenceHistogram"></canvas>
        </div>
    </div>
    <div class="chart-container">
        <h3>Hourly Activity</h3>
        <canvas id="hourlyChart"></canvas>
    </div>
</section>
        
        <section class="section">
            <h2 class="section-title">Recent Activity</h2>
            <div id="recentEvents" class="recent-events">
                <p>No recent events</p>
            </div>
        </section>
    </div>
    </div>

    <script>
        // Global variables
        var currentCaptcha = null;
        var userPath = [];
        var isDrawing = false;
        var mazeImage = null;
        var analyticsData = null;
        var performanceChart = null;
        var learningChart = null;
        var pathLengthChart = null;
        var confidenceChart = null;
        var hourlyChart = null;
        
        // Canvas setup
        var canvas = document.getElementById('mazeCanvas');
        var ctx = canvas.getContext('2d');
        
        // Initialize charts
        function initCharts() {
            var perfCtx = document.getElementById('performanceChart');
            if (perfCtx) {
                performanceChart = new Chart(perfCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Successful', 'Failed', 'Bot Detected'],
                        datasets: [{
                            data: [0, 0, 0],
                            backgroundColor: ['#4ade80', '#f87171', '#fbbf24'],
                            borderColor: ['#22c55e', '#dc2626', '#f59e0b'],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
            }
        }
        
        // Load new captcha
        function loadNewCaptcha() {
            fetch('/api/captcha?difficulty=medium', {
                credentials: 'same-origin'
            })
                .then(function(response) {
                    return response.json();
                })
                .then(function(captcha) {
                    if (captcha.error) {
                        showStatus('Error: ' + captcha.error, 'error');
                        return;
                    }
                    
                    currentCaptcha = captcha;
                    userPath = [];
                    isDrawing = false;
                    
                    // Load maze image
                    mazeImage = new Image();
                    mazeImage.onload = function() {
                        drawMaze();
                        // Draw start and end indicators
                        drawStartEnd();
                        showStatus('New captcha loaded! Draw a path from green to red.', 'info');
                    };
                    mazeImage.src = captcha.maze_image;
                })
                .catch(function(error) {
                    showStatus('Error loading captcha. Please try again.', 'error');
                });
        }
        
        // Draw maze
        function drawMaze() {
            if (!mazeImage) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mazeImage, 0, 0);
            
            // Draw user path
            if (userPath.length > 0) {
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(userPath[0].x, userPath[0].y);
                
                for (var i = 1; i < userPath.length; i++) {
                    ctx.lineTo(userPath[i].x, userPath[i].y);
                }
                
                ctx.stroke();
            }
            
        // Draw bot path if exists
        if (typeof botPath !== 'undefined' && botPath.length > 0) {
            console.log('Drawing bot path in drawMaze():', botPath);
            console.log('Bot path length:', botPath.length);
            
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.setLineDash([5, 5]);
            
            // Check if botPath is already in canvas coordinates or needs conversion
            var firstPoint = botPath[0];
            console.log('First bot point:', firstPoint);
            
            // Check if points are already canvas coordinates (x,y) or maze coordinates (row,col)
            if (firstPoint.length >= 2 && firstPoint[0] > 20 && firstPoint[1] > 20) {
                // Already canvas coordinates, use directly
                console.log('Using canvas coordinates directly');
                var startX = firstPoint[0];
                var startY = firstPoint[1];
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                for (var i = 1; i < botPath.length; i++) {
                    var x = botPath[i][0];
                    var y = botPath[i][1];
                    ctx.lineTo(x, y);
                }
            } else {
                // Maze coordinates, convert to canvas coordinates
                console.log('Converting maze coordinates to canvas');
                var startX = botPath[0][1] * 20 + 20; // col to x with offset
                var startY = botPath[0][0] * 20 + 20; // row to y with offset
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                for (var i = 1; i < botPath.length; i++) {
                    var x = botPath[i][1] * 20 + 20; // col to x with offset
                    var y = botPath[i][0] * 20 + 20; // row to y with offset
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            ctx.setLineDash([]);
            console.log('Bot path drawing completed');
        }
        }
        
        // Draw start and end indicators
        function drawStartEnd() {
            if (!currentCaptcha) return;
            
            // Save current context state
            ctx.save();
            
            // Draw a circle around start
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(currentCaptcha.canvas_start[0] + 10, currentCaptcha.canvas_start[1] + 10, 15, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw "S" text in start
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('S', currentCaptcha.canvas_start[0] + 6, currentCaptcha.canvas_start[1] + 15);
            
            // Draw a circle around end
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(currentCaptcha.canvas_end[0] + 10, currentCaptcha.canvas_end[1] + 10, 15, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw "E" text in end
            ctx.fillStyle = '#ff0000';
            ctx.fillText('E', currentCaptcha.canvas_end[0] + 6, currentCaptcha.canvas_end[1] + 15);
            
            // Restore context state
            ctx.restore();
        }
        
        // Canvas mouse events
        canvas.addEventListener('mousedown', function(e) {
            if (!currentCaptcha) return;
            
            var rect = canvas.getBoundingClientRect();
            var x = Math.floor(e.clientX - rect.left);
            var y = Math.floor(e.clientY - rect.top);
            
            console.log('MouseDown at:', x, y);
            console.log('Expected start:', currentCaptcha.canvas_start);
            
            isDrawing = true;
            userPath = [{x: x, y: y}];
            drawMaze();
            drawStartEnd(); // Redraw indicators
        });

        canvas.addEventListener('mousemove', function(e) {
            if (!isDrawing) return;
            
            var rect = canvas.getBoundingClientRect();
            var x = Math.floor(e.clientX - rect.left);
            var y = Math.floor(e.clientY - rect.top);
            
            var lastPoint = userPath[userPath.length - 1];
            if (Math.abs(x - lastPoint.x) > 3 || Math.abs(y - lastPoint.y) > 3) {
                userPath.push({x: x, y: y});
                drawMaze();
                drawStartEnd(); // Redraw indicators
            }
        });

        canvas.addEventListener('mouseup', function() {
            isDrawing = false;
            console.log('MouseUp - Final path length:', userPath.length);
            console.log('Path points:', userPath.slice(0, 3), '...', userPath.slice(-3));
        });

        canvas.addEventListener('mouseleave', function() {
            isDrawing = false;
        });
        
        // Clear path
        function clearPath() {
            userPath = [];
            botPath = [];
            isDrawing = false;
            drawMaze();
            showStatus('Path cleared. Start drawing from green square.', 'info');
        }
        
        // Verify solution
        function verifySolution() {
            if (!currentCaptcha) {
                showStatus('Please load a captcha first.', 'error');
                return;
            }
            
            console.log('=== VERIFICATION ATTEMPT ===');
            console.log('Path length:', userPath.length);
            console.log('Path points:', userPath);
            console.log('Expected start:', currentCaptcha.canvas_start);
            console.log('Expected end:', currentCaptcha.canvas_end);
            
            if (userPath.length < 2) {
                showStatus('Please draw a path from start to end. Current path: ' + userPath.length + ' points', 'error');
                return;
            }
            
            // Quick client-side validation
            var firstPoint = userPath[0];
            var lastPoint = userPath[userPath.length - 1];
            var startMaze = [(firstPoint[0] - 20) / 20, (firstPoint[1] - 20) / 20];
            var endMaze = [(lastPoint[0] - 20) / 20, (lastPoint[1] - 20) / 20];
            
            console.log('Client conversion - Start:', startMaze, 'End:', endMaze);
            console.log('Expected maze - Start:', currentCaptcha.start, 'End:', currentCaptcha.end);
            
            showStatus('Analyzing your solution...', 'info');
            
            // Send raw canvas coordinates, let server handle conversion
            fetch('/api/verify', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'same-origin',
                body: JSON.stringify({
                    captcha_id: currentCaptcha.captcha_id,
                    path: userPath
                })
            })
            .then(function(response) {
                return response.json();
            })
            .then(function(result) {
                if (result.success) {
                    var confidence = result.analysis && result.analysis.confidence ? 
                        (result.analysis.confidence * 100).toFixed(1) : '0.0';
                    showStatus('Success: ' + result.message + ' (Confidence: ' + confidence + '%)', 'success');
                    setTimeout(loadNewCaptcha, 2000);
                } else {
                    var confidence = result.analysis && result.analysis.confidence ? 
                        (result.analysis.confidence * 100).toFixed(1) : '0.0';
                    showStatus('Error: ' + result.message + ' (Confidence: ' + confidence + '%)', 'error');
                }
                
                updateAnalytics();
            })
            .catch(function(error) {
                showStatus('Error verifying solution. Please try again.', 'error');
                console.error('Error verifying solution:', error);
            });
        }
        
        // Simulate bot
        function simulateBot() {
            console.log('simulateBot called, currentCaptcha:', currentCaptcha);
            if (!currentCaptcha) {
                showStatus('Please load a captcha first.', 'error');
                return;
            }
            
            console.log('Attempting bot simulation with captcha_id:', currentCaptcha.captcha_id);
            showStatus('Simulating bot behavior...', 'info');
            
            fetch('/api/bot-simulate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'same-origin',
                body: JSON.stringify({
                    captcha_id: currentCaptcha.captcha_id
                })
            })
            .then(function(response) {
                if (!response.ok) {
                    throw new Error('HTTP error! status: ' + response.status);
                }
                return response.json();
            })
            .catch(function(error) {
                console.error('Fetch error:', error);
                showStatus('Network error: ' + error.message, 'error');
                throw error;
            })
            .then(function(result) {
                console.log('Bot simulation response:', result);
                
                // Handle the actual response structure
                if (result.success !== undefined) {
                    var success = result.success;
                    var detected = result.bot_detected ? 'Bot' : 'Human';
                    var confidence = (result.bot_score ? (1 - result.bot_score) * 100 : 0).toFixed(1);
                    
                    showStatus('Bot simulation complete: ' + detected + ' detected (Confidence: ' + confidence + '%)', result.bot_detected ? 'error' : 'success');
                    
                    // Draw bot path if available
                    if (result.path && result.path.length > 0) {
                        console.log('Drawing bot path:', result.path);
                        // Keep bot path as canvas coordinates for direct drawing
                        botPath = result.path;
                        console.log('Bot path set for drawing:', botPath);
                        drawMaze();
                    }
                } else if (result.error) {
                    showStatus('Bot simulation failed: ' + result.error, 'error');
                } else {
                    console.log('Unexpected response structure:', result);
                    showStatus('Bot simulation failed - unexpected response', 'error');
                }
                
                updateAnalytics();
            })
            .catch(function(error) {
                showStatus('Error simulating bot. Please try again.', 'error');
                console.error('Error simulating bot:', error);
            });
        }
        
        // Update analytics with comprehensive display
        function updateAnalytics() {
            console.log('Updating analytics...');
            fetch('/api/analytics')
                .then(function(response) {
                    console.log('Analytics response status:', response.status);
                    return response.json();
                })
                .then(function(data) {
                    console.log('Analytics data received:', data);
                    analyticsData = data;
                    
                    // Update basic stats with error checking
                    var total = (data.successful_verifications || 0) + (data.bot_detected || 0);
                    document.getElementById('totalAttempts').textContent = total;
                    
                    // Update successful verifications if element exists
                    var successElement = document.getElementById('successful_verifications');
                    if (successElement) {
                        successElement.textContent = data.successful_verifications || 0;
                    }
                    
                    document.getElementById('botDetected').textContent = data.bot_detected || 0;
                    document.getElementById('patternsLearned').textContent = data.learning_status ? data.learning_status.behaviors_learned : 0;
                    document.getElementById('learnedPatterns').textContent = data.human_patterns ? data.human_patterns.length : 0;
                    
                    // Calculate success rate
                    var successRate = total > 0 ? 
                        ((data.successful_verifications / total) * 100).toFixed(1) : 0;
                    var successRateElement = document.getElementById('successRate');
                    if (successRateElement) {
                        successRateElement.textContent = successRate + '%';
                    }
                    
                    // Update average solve time
                    var avgTime = data.learning_status ? data.learning_status.avg_human_solve_time : 0;
                    var avgTimeElement = document.getElementById('avgSolveTime');
                    if (avgTimeElement) {
                        avgTimeElement.textContent = avgTime.toFixed(1) + 's';
                    }
                    
                    // Update additional metrics with safe checks
                    var wallToleranceElement = document.getElementById('wallTouchTolerance');
                    if (wallToleranceElement) {
                        wallToleranceElement.textContent = 'Max 8 wall touches';
                    }
                    
                    var sessionElement = document.getElementById('sessionCount');
                    if (sessionElement) {
                        sessionElement.textContent = data.real_time_stats ? data.real_time_stats.current_session_count : 0;
                    }
                    
                    var confidenceElement = document.getElementById('avgConfidence');
                    if (confidenceElement) {
                        confidenceElement.textContent = data.real_time_stats ? (data.real_time_stats.avg_confidence * 100).toFixed(1) + '%' : '0%';
                    }
                    
                    // Update performance chart
                    if (performanceChart) {
                        performanceChart.data.datasets[0].data = [
                            data.successful_verifications || 0,
                            total - (data.successful_verifications || 0) - (data.bot_detected || 0),
                            data.bot_detected || 0
                        ];
                        performanceChart.update();
                    }
                    
                    // Update learning chart
                    if (learningChart) {
                        learningChart.data.datasets[0].data = [
                            data.learning_status ? data.learning_status.behaviors_learned : 0,
                            data.learning_status ? data.learning_status.human_patterns_stored : 0,
                            data.avg_path_length || 0
                        ];
                        learningChart.update();
                    }
                    
                    // Update path length histogram
                    if (pathLengthChart && data.path_length_histogram) {
                        pathLengthChart.data.labels = data.path_length_histogram.bins;
                        pathLengthChart.data.datasets[0].data = data.path_length_histogram.counts;
                        pathLengthChart.update();
                    }
                    
                    // Update confidence histogram
                    if (confidenceChart && data.confidence_histogram) {
                        confidenceChart.data.labels = data.confidence_histogram.bins;
                        confidenceChart.data.datasets[0].data = data.confidence_histogram.counts;
                        confidenceChart.update();
                    }
                    
                    // Update hourly activity chart
                    if (hourlyChart && data.hourly_stats) {
                        var hours = data.hourly_stats.map(function(item) { return item.hour + ':00'; });
                        var humanData = data.hourly_stats.map(function(item) { return item.human; });
                        var botData = data.hourly_stats.map(function(item) { return item.bot; });
                        
                        hourlyChart.data.labels = hours;
                        hourlyChart.data.datasets[0].data = humanData;
                        hourlyChart.data.datasets[1].data = botData;
                        hourlyChart.update();
                    }
                    
                    // Update average displays
                    if (data.avg_path_length !== undefined) {
                        var avgPathElement = document.getElementById('avgPathLength');
                        if (avgPathElement) {
                            avgPathElement.textContent = data.avg_path_length.toFixed(1);
                        }
                    }
                    
                    if (data.avg_confidence !== undefined) {
                        var avgConfElement = document.getElementById('avgConfidence');
                        if (avgConfElement) {
                            avgConfElement.textContent = (data.avg_confidence * 100).toFixed(1) + '%';
                        }
                    }
                    
                    // Update recent events display
                    if (data.recent_events && data.recent_events.length > 0) {
                        var recentEventsHtml = '';
                        data.recent_events.slice(-10).reverse().forEach(function(event) {
                            var time = new Date(event.timestamp * 1000).toLocaleTimeString();
                            var eventClass = event.type === 'human_verified' ? 'human-event' : 
                                             event.type === 'bot_detected' ? 'bot-event' : 'system-event';
                            var confidence = (event.confidence * 100).toFixed(1);
                            
                            recentEventsHtml += '<div class="event-item ' + eventClass + '">';
                            recentEventsHtml += '<span class="event-time">' + time + '</span>';
                            recentEventsHtml += '<span class="event-type">' + event.type.replace('_', ' ').toUpperCase() + '</span>';
                            recentEventsHtml += '<span class="event-confidence">Confidence: ' + confidence + '%</span>';
                            if (event.reasons && event.reasons.length > 0) {
                                recentEventsHtml += '<div class="event-reasons">Reasons: ' + event.reasons.join(', ') + '</div>';
                            }
                            if (event.wall_touches !== undefined) {
                                recentEventsHtml += '<div class="event-wall">Wall touches: ' + event.wall_touches + '</div>';
                            }
                            recentEventsHtml += '</div>';
                        });
                        document.getElementById('recentEvents').innerHTML = recentEventsHtml;
                    }
                    
                    console.log('Analytics updated successfully');
                })
                .catch(function(error) {
                    console.error('Error updating analytics:', error);
                });
        }
        
        // Show status message
        function showStatus(message, type) {
            var statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
            statusDiv.classList.remove('hidden');
            
            if (type === 'info') {
                setTimeout(function() {
                    if (statusDiv.classList.contains('info')) {
                        statusDiv.classList.add('hidden');
                    }
                }, 5000);
            }
        }
        
        // Initialize page
        window.onload = function() {
            console.log('Page fully loaded');
            initCharts();
            loadNewCaptcha();
            updateAnalytics();
            
            // Update analytics every 10 seconds
            setInterval(updateAnalytics, 10000);
        }
        
        // Initialize charts with error checking
        function initCharts() {
            console.log('Initializing charts...');
            
            // Performance chart (doughnut)
            var performanceCtx = document.getElementById('performanceChart');
            if (!performanceCtx) {
                console.error('Performance chart canvas not found!');
                return;
            }
            
            try {
                performanceChart = new Chart(performanceCtx.getContext('2d'), {
                    type: 'doughnut',
                    data: {
                        labels: ['Successful', 'Failed', 'Bot Detected'],
                        datasets: [{
                            data: [0, 0, 0],
                            backgroundColor: [
                                'rgba(74, 222, 128, 0.8)',
                                'rgba(248, 113, 113, 0.8)',
                                'rgba(249, 115, 115, 0.8)'
                            ],
                            borderColor: [
                                'rgba(74, 222, 128, 1)',
                                'rgba(248, 113, 113, 1)',
                                'rgba(249, 115, 115, 1)'
                            ],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
                console.log('Performance chart initialized');
            } catch (error) {
                console.error('Error initializing performance chart:', error);
            }
            
            // Learning progress chart (bar)
            var learningCtx = document.getElementById('learningChart');
            if (!learningCtx) {
                console.error('Learning chart canvas not found!');
                return;
            }
            
            try {
                learningChart = new Chart(learningCtx.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: ['Behaviors Learned', 'Patterns Stored', 'Avg Solve Time'],
                        datasets: [{
                            label: 'Learning Progress',
                            data: [0, 0, 0],
                            backgroundColor: 'rgba(74, 222, 128, 0.6)',
                            borderColor: 'rgba(74, 222, 128, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
                console.log('Learning chart initialized');
            } catch (error) {
                console.error('Error initializing learning chart:', error);
            }
            
            // Initialize histogram charts
            try {
                // Path length histogram
                var pathLengthCtx = document.getElementById('pathLengthHistogram');
                if (pathLengthCtx) {
                    pathLengthChart = new Chart(pathLengthCtx.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Path Length Frequency',
                                data: [],
                                backgroundColor: 'rgba(74, 222, 128, 0.6)',
                                borderColor: 'rgba(74, 222, 128, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Frequency'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Path Length Range'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Confidence histogram
                var confidenceCtx = document.getElementById('confidenceHistogram');
                if (confidenceCtx) {
                    confidenceChart = new Chart(confidenceCtx.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Confidence Score Frequency',
                                data: [],
                                backgroundColor: 'rgba(248, 113, 113, 0.6)',
                                borderColor: 'rgba(248, 113, 113, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Frequency'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Confidence Range'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Hourly activity chart
                var hourlyCtx = document.getElementById('hourlyChart');
                if (hourlyCtx) {
                    hourlyChart = new Chart(hourlyCtx.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Human Users',
                                data: [],
                                borderColor: 'rgba(74, 222, 128, 1)',
                                backgroundColor: 'rgba(74, 222, 128, 0.1)',
                                fill: true
                            }, {
                                label: 'Bot Attempts',
                                data: [],
                                borderColor: 'rgba(248, 113, 113, 1)',
                                backgroundColor: 'rgba(248, 113, 113, 0.1)',
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Count'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Hour of Day'
                                    }
                                }
                            }
                        }
                    });
                }
                
                console.log('Histogram charts initialized');
            } catch (error) {
                console.error('Error initializing histogram charts:', error);
            }
        };
    </script>
</body>
</html>